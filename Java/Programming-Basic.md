
# `Chapter 01` 자바를 시작하기 전에

## 1. 자바
> ### **자바의 특징**
- 운영체제에 독립적
- 객체지향언어
- 비교적 배우기 쉬움
- 자동 메모리 관리 > 가비지컬렉터
- 네트워크와 분산처리 지원
- 멀티쓰레드 지원
- 동적 로딩 지원
<br>

## 2. 자바개발환경 구축
> ### **JDK : 자바개발도구**
- JDK 설치
    - bin 디렉토리 > 실행파일
        - *.dll : 독립 실행 불가능 
        - *.exe : 독립 실행 가능 > javac.exe / java.exe / javadoc.exe / ...
- 환경변수 설정 : 해당 디렉토리 내 파일을 경로없이 이름만으로 사용 
    - 시스템 > 정보 > 고급 > 환경변수 
    - `Add` : JAVA_HOME, C:\ ... \jdk-11.0.2
    - `Edit` : Path > %JAVA_HOME%\bin
<br>

> ### **Eclipse**
- eclipse.ini 
    - `Edit` : -vm ... > 소규모 자바도구의 경로를 수정하여 안정성 증가
- window > preference 
    - font : 가독성 높은 고정폭 폰트 선호 
    - encoding > UTF-8
    - theme
<br>

## 3. 자바로 프로그램작성하기

> ### **Hello world!!**
1. 메모장
	- 코드 작성
	- 산출물(결과물) > "Hello.java" > Source Code File
	- 소스 파일은 프로그램이 아니다. > 텍스트 파일이다.
	- 프로그래밍 코드를 작성 > 프로그램 완성 > CPU에게 명령어 전달!!
	- 어떤 언어로 구성? > 자바(X) > 사람이 쓰는 언어로 구성(인간)
	- 소스 파일의 명령어의 실행 주체 > 컴퓨터(CPU) > 이진데이터(1, 0)

2. javac.exe Hello.java
	- 1차 컴파일
	- javac.exe 파일명
	- javac.exe > Java Compiler >  사람이 작성한 코드를 컴퓨터가 이해하는 코드로 번역 하는 프로그램
	- 번역 작업 실행 > Compile
	- 산출물 > "Hello.class" > 실행 파일(클래스 파일)
	- Hello.class > 컴퓨터 실행(바이너리 코드, 이진 데이터, 기계어, Machine Code)
    - 중간언어(IL) 산출물 > 임시번역본 > 실행파일(=프로그램)
	
3. java.exe Hello
	- 2차 컴파일, 인터프리터, JIT(Just in time) 컴파일러	//자바는 컴파일을 두 번!
	- java.exe > Java Compiler, Java Interpreter, 실행기
	- java.exe 클래스명 > 최종 실행                         //산출물 없음
    - 최종적으로 운영체제에 적합한 기계어로 바꿔주는 번역 작업  
<br><br>

# `Chapter 02` 변수
---
## 1. 메모리
> ### **주 기억장치 RAM (memory)**
- 데이터를 다루는 최소 단위 1byte = 8bit > 0~255
- 저장범위가 이미 규정되어 있음 > 1byte, 2byte, 4byte, 8byte 
- 프로그램이 필요로 하는 자료형 만큼의 공간을 '연속적으로' 할당
<br>

## 2. 자료형
> ### **기본형 Primitive type; 원시형, 값형**
 1. 숫자형
    - **정수형**
        |분류     | 크기          | 개수| 범위|
        |--|--|--|--|
        |`byte`   | 1byte(=8bit)  | 2<sup>8</sup>  | -128 ~ 127 |
        |`short`  | 2byte(=16bit) | 2<sup>16</sup> |-32,768 ~ 32,767|
        |`**int**`| 4byte(=32bit) | 2<sup>32</sup> |-2<sup>31</sup> ~ 2<sup>31</sup>-1|
        |`long`   | 8byte(=64bit) | 2<sup>64</sup> |-2<sup>63</sup> ~ 2<sup>63</sup>-1|
        - 8bit = 부호비트(양0,음1) 1bit + 데이터비트 7bit > 자바는 부호가 있는 자료형만 표현 가능
        -  만약 4byte가 넘는 범위의 수를 다뤄야 한다면 다른언어를 선택! 
      <br>
    - **실수형**
        |분류     | 크기          | 범위| 정밀도 | 유형|
        |--|--|--|--|--|
        |`float`  | 4byte | 무제한  | 7자리|단정도형(정밀도 > 유효한 숫자 저장할 범위) |
        |`**double**` |  8byte | 무제한 |15자리|배정도형(단정도×2 정밀도)|
        - 부동소수점 방식 > 부호 + 지수부 + 가수부 > ±(1.가수부)×2<sup>지수부-bias</sup>
        - `float` > 부호 1bit + 지수부 8bit +가수부 23bit  
        - `double` > 부호 1bit + 지수부 11bit + 가수부 52bit
        - 단점 : 가수부가 제한적 > 넘어가는 유효숫자는 버림 > 손실분으로 인한 부정확한 계산

2. 문자형
    - **문자형**
        |분류  | 크기  | 특징           | 
        |------|-------|---------------|
        |`char`| 2byte | 유니코드 지원  | 
        - 유니코드 : 2byte를 사용하는 문자표현
3. 논리형
    - **논리형**
        - `boolean` : 1byte > true, false
<br>

> ### **참조형 Reference Type**  
1. String
    - 보통 char보다 String을 많이 사용
    - 식별자를 "" 안에 넣으면 그냥 문자가 되며 의미가 사라짐
    - 숫자형 데이터 중 수치가 아닌 데이터는 문자열로 표현 > e)주민등록번호, 상품코드
<br>

> ### **특수문자 Escape Sequence**
1. \n 
    - new line, line feed, 개행 문자
    - 문자열 리터럴에서 '엔터'역할
    -  엔터 : 윈도우(\r\n), 맥os(\r), 리눅스(\n) > [\r\n의 유래](https://jw910911.tistory.com/90)
2. \r
    - carriage return
    - 커서(캐럿)의 위치를 현재 라인의 맨앞(첫번째 열)으로 이동
    - 이클립스 콘솔에서는 제대로 동작 안함
3. \t
    - tab, 탭문자
    - 탭 > 행동(X) > 지표(O) > 이미 정해져있는 위치를 표시한 요소
    - 서식 작업(열 맞추기)
4. \b
    - Backspace
    - 콘솔에서는 동작O, 이클립스 콘솔에서는 동작x
5. \\", \\', \\\
    - 이미 무언가를 하는 문자들을 의미없게 만드는 역할  
<br>

## 3. 변수
> ### **변수 Variable** 
- 개발자가 명령어를 사용하여 할당받은 메모리 공간
- 목적 : 원하는 데이터를 읽거나 쓰기위한 공간 
- 32bit 16진수의 메모리 번지를 갖는 할당받은 공간에 별칭(이름)을 지정 
<br>

- **변수명 생성 규칙**
    - 영문자 사용 + 숫자 사용 + 특수문자(_) > 권장(필수)
    - 숫자로 시작 불가능
    - 예약어 사용 불가능
    - 의미있게**
<br>

- **변수 선언과 초기화**
    ```java
    byte math1;  //변수 선언
    math = 95;   //변수 초기화
 
    byte math2 = 100;  //변수 선언 및 초기화

    byte math3, math4, math5 = 100;
    ```
<br>

> ### **식별자 명명법 패턴** > 코딩 컨벤션
1. 헝가리언 표기법
    - 식별자를 만들 때 식별자의 **접두어**로 해당 자료형을 표시하는 방법
    - 사용) 인터페이스명 `interface IHello {}`
2. 파스칼 표기법 
    - 식별자 단어의 첫문자를 **"대"**문자로 표기 + 나머지 문자를 소문자로 표기
    - 2개 이상의 단어로 만든 합성어 > 각 단어의 첫문자를 대문자로 표기
    - 사용) 클래스명 `class EnglishScore {}`
3. 캐멀 표기법
    - 식별자 단어의 첫문자를 **"소"**문자로 표기 + 나머지 문자를 소문자로 표기
    - 2개 이상의 단어로 만든 합성어 > 각 단어의 첫문자를 대문자로 표기
    - 사용) 변수명, 메소드명 `int englishScore;`    
4. 스네이크 표기법
    - 전부 소문자로 표기
    - 합성어 > 각 단어를 **'_'**로 연결
    - 사용) 정해지지 않음 > 마음대로.. `int english_score;`
5. 케밥 표기법
    - 전부 소문자로 표기
    - 합성어 > 각 단어를 **'-'**로 연결
    - 사용) 자바 불가능(→ minus로 인식), 나중에 다른 과목에서 사용(HTML, CSS) `int english-score;`
<br>

## 4. 상수와 리터럴
> ### **상수**
- 변수 vs 상수(상수, 리터럴)
    - 변수 : 의미 있음 + 값 변경 가능  > 표현식은 동일한데 값이 바뀔 수 있음 
    - 상수 : **의미 있음** + 값 변경 불가  > 표현식은 동일한데 값이 안 바뀜 > final 상수    
    - 리터럴 : 의미 없음 + 값 변경 불가 > 표현식은 동일한데 값이 안 바뀜 > 데이터 상수 
- 상수의 특징
    - 초기화 이후에는 더 이상 값 변경 불가
    - 상수는 의미가 없는 리터럴을 의미있게 사용하기 위함
    - 대문자로 작성하여 변수와 구분! (가독성up)
<br>

> ### **리터럴**
- **정수형 리터럴 int**
    - 예로부터 int 자료형의 크기는 운영체제의 bit와 동일 
    - 32bit에서 64bit 운영체제로 변경될 때는 혼란방지를 위해 int 자료형을 32bit로 고정
- Long형 리터럴 : 접미어(L) 
    - 정수형 리터럴 int의 범위를 벗어나 표현 불가
    - 거의 int만 사용 + 가끔씩 long을 사용
- **실수형 리터럴 double** 
    - float보다 높은 정밀도
    - 손실분의 발생으로 잘 사용하지 않음
- Float형 리터럴 : 접미어(F)
- **문자형 리터럴 ''**
    - 반드시 한 개의 문자만 저장 가능
    - 문자열 리터럴 ""은 문자의 집합
- **논리형 리터럴 true, false**
<br>
    
## 5. 형변환
> ### **형변환 Casting** > 자료형 변환, Data Type Casting   
- 코드를 유연하게 작성하기 위한 도구
- 대입연산자 '=' >  LVale의 자료형과 RValue의 자료형은 반드시*** 동일해야 한다. 
- 크기: byte(1) < short(2) < int(4) < long(8) < float(4) < double(8)

**1. 명시적 형변환(= 강제 타입 변환)** > 주의!!***
- 작은형 = 큰형
- 작은형이 소화할 수 있는 범위의 원본값 > 복사 가능
- 작은형이 소화할 수 없는 범위의 원본값 > 손실분 발생*** > Overflow(오버플로우)
    - int = long;
    - int = double;
    - long = double;  

**2. 암시적 형변환(= 자동 타입 변환)**  > 안전
- 큰형 = 작은형 
    - long = int; > 8칸 = 4칸
    - double = int;
    - double = long;
<br>

> ### **"변수 자료형 = 리터럴 자료형" 형변환**

**1. 변수 = 정수형 리터럴 int**
- 작은형 = 큰형 > 명시적 형변환x > 서비스 문법
    - `byte b1 = 10;`
    - `short s1 = 10;`
- int = int
    - `int i1 = 10;`
- 큰형 = 작은형 > 암시적 형변환 
    - `long l1 = 10;`

**2. 변수 = 실수형 리터럴 double**
- 작은형 = 큰형 > 명시적 형변환
    - `float f1 = 3.14F;` > (float)대신 F를 표기
    - 가수 24번째 자리값이 1이면 버릴 때 23번째 자리값이 1증가 > 반올림
- double = double
    - `double d1 = 3.14;`
<br>

> ### **boolean, char 형변환**
- boolean > 형변환 불가능
- **char** > 형변환 가능
    - 겉보기엔 문자, 내부는 숫자
    - char는 숫자형 자료형 중의 하나로 취급한다.
    - 유효성 검사에 사용
    - char <-> 정수
        - char(2) → short(2) > `short s1 = (short) c1;`
        - short(2) → char(2) > `char c1 = (char) s1;`
        - char(2) → int(4) > `int i1 = c1;`
        - int(4) → char(2) > `char c1 = (char) i1;`
<br>

> ### **String 형변환**
- String > ‘문자열→ 값형’ 형변환 불가 *** > 유틸 클래스로 해당 작업 가능

**1. 문자열 → 값형**
- Byte.parseByte("10")
- Short.parseShort("10")
- Integer.parseInt("10")
- Long.parseLong("10")
- Float.parseFloat("3.14")
- Double.parseDouble("3.14")
- Boolean.parseBoolean("true")
    
- Char (X) > 다른 방법으로 구현 > “A”.charAt(0)
    
**2. 값형 → 문자열**
- String.valueOf(100) > "100"
- String.valueOf(3.14) > "3.14"
- String.valueOf(true) > "true"
<br>

## 6. 변수와 시스템 입력
> ### **출력**
- System.out.print() > 값을 출력하고 종료
- System.out.println() > 값을 출력하고 엔터치고 종료
- <u>System.out.printf()</u> > 여러가지 출력 "형식 문자" 제공 
<br>

> ### **printf의 형식문자** > 지시자, PlaceHolder
- 가독성 향상
- 형식 문자를 맞추지 않으면 오류 발생

    - %s -> String 
    - %d -> Decimal(정수; byte, short, int, long)
    - %f -> Float(실수; float, double) 
    - %c -> Char 
    - %b -> Boolean

**형식 문자의 확장 기능**
- %숫자d, %숫자s ...
    - 모든 형식 문자에 적용
    - 출력할 너비 지정
    - (+) : 우측 정렬 > 수치데이터 숫자(연산용) 
    - (-) : 좌측 정렬 > 문자열
    - 서식 작업에 사용 > 탭문자와 같이 사용한다. > ** 가장 큰 자리수에 맞출 것 > 권장
    - 지정한 출력 너비보다 데이터가 클 때 > 데이터 크기만큼 출력
- %.숫자f
    - %f 전용
    - 소수점 이하 출력 자릿수 지정
- %,d
    - %d, %f 적용
    - 천단위 표기(3자리)
<br>

> ### **입력**
- System.in.read()
   - System.out.print() 반대 기능
   - 기본 기능
   - 사용 불편함 > 잘 안씀
- BufferedReader 클래스***
- Scanner 클래스
<br>

> ### **Scanner**
- `System.in.read()`의 단점 > 2개 이상의 키가 조합된 한글과 통 문자열을 읽지 못함 > 보완!
- import java.util.Scanner;
- 입력된 모든 내용을 문자열로 읽음
<br><br>

# `Chapter 03` 연산자
---
## 1. 연산자

> ### **연산자, Operator**
- 수학 연산자와 동일
- 피연산자를 대상으로 미리 정해진 연산(행동)을 한 후에 연산(행동)의 결과를 반환하는 요소
- 주로 기호로 많이 사용 + 단어

1. 문장, Statement
    - `int sum = 10 + 20;`
2. 표현식, Expression
    - 문장을 구성하는 최소 단위 > 더 이상 쪼개지지 않는 단위
    - `int sum;`, `10 + 20;`, `sum = 30;`, `10`, `20`

3. 연산자, Operator
    - +. =
4. 피연산자, Operand
    - + : 10, 20
    - = : sum, 30

5. 연산자 우선순위
6. 연산자 연산방향
<br>

## 2. 연산자 종류
> ### **연산자 종류**

**1. 행동**
- 산술 연산자 : +, -, *, /, %
- 비교 연산자 : >, >=, <, <=, ==, !=
- 논리 연산자 : &&, ||, !
- 대입 연산자 : =, +=, -=, *=, /=, %=
- 증감 연산자 : ++, --
- 조건 연산자 : A ? B : C 
- 비트 연산자

**2. 형태(피연산자 갯수)**
- 1항 연산자
- 2항 연산자
- 3항 연산자
<br>


> ### **산술 연산자** > +, -, *, /, %
- 2항 연산자
- 피연산자는 숫자형(정수, 실수)을 가진다. 
- *** 모든 산술 연산자의 결과 자료형은 두 피연산자의 자료형 중에서 더 크기가 큰 자료형으로 반환된다. `10 / 3 = 3`, `10.0 / 3 = 3. 333` 
- ***  `int i = 1,000,000,000 + 2,000,000,000;` (x) > +, - , * 특히 오버플로우 주의!!!

**cf) 문자열 연산자 +**
- 2항 연산자
- 피연산자는 문자열
- 연산의 결과로 두 문자열을 합한 문자열을 반환
    - 문자열 + 문자열 = 문자열
    - 문자열 + 비문자열 = 문자열
    - 비문자열 + 문자열 = 문자열
    - <u>비문자열 + 비문자열 => 산술 연산자</u>
<br>

> ### **비교 연산자** > >, >=, <, <=, ==, !=
- 2항 연산자
- 피연산자들의 우위(동등) 비교하는 연산자
- 피연산자는 숫자형
- 연산의 결과는 boolean
- *** 비교할 때 주체를 먼저, 비교대상을 나중에 쓰는 걸 권장 
- `0.1 == 0.1f` > **false**  > 부동 소수점 방식 > 0.1을 정확하게 표현하지 않음

**cf) 문자열의 비교 연산자**
- 문자열 String은 우위 비교가 불가능
- **** 자바는 문자열을 대상으로 ==, != 연산자를 절대로 사용하면 안된다!!
- 문자열 비교 ⇒ equals() 
<br>

> ### **논리 연산자** > &&, ||, !
- 2항 연산자(&&, ||), 1항 연산자(!)
- 피연산자와 연산의 결과 모두 boolean
- 피연산자를 대상으로 정해진 규칙에 따라 정해진 값을 반환하는 연산자

    | A `&&` B = ? | A `||` B = ? |
    | --- | --- |
    | T `&&` T = T | T `||` T = T|
    | T `&&` F = F | T `||` F = T	 |
    | F `&&` T = F	 | F `||` T = T	 |
    | F `&&` F = F | F `||` F = F |
<br>

> ### **대입 연산자** > =, +=, -=, *=, /=, %=
- LValue(변수) = RValue(상수, 변수) > 자료형 동일!! > 형변환
- 대입 연산자는 모든 연산자들 중 연산자 우선 순위가 가장 낮다.
<br>

> ### **증감 연산자** > ++, --
- 1항 연산자, 단항 연산자
- 피연산자는 숫자형
- 기존의 값에 1을 더하거나, 1을 뺸다.
- 연산자와 피연산자의 위치를 바꿀 수 있다. > 연산자 우선 순위가 달라진다.
    - ++n: 전위 배치(전치) > 연산자 우선 순위가 가장 높음, 소괄호 제외
    - n++: 후위 배치(후치) > 연산자 우선 순위가 가장 낮음
- *** 증감 연산자를 다른 연산과 함께 한 문장에서 사용하지 않는다. > 권장
<br>

> ### **조건 연산자** > A ? B : C
- A조건식에 따라 값을 반환 >  `true => B`, `false => C` 
- 3항 연산자
- ?: 연산자
- A, B, C 피연산자
    - A : boolean
    - B, C : 상수, 변수, 연산식, 메소드 > 값
- *** 반드시 B와 C의 자료형이 동일해야 한다.
<br>

## 3. 연산자 순서
> ### **연산자 우선 순위**
- 하나의 문장에 속한 모든 연산자들은 실행 순서를 가진다
- 산술 연산자 > 비교 연산자 > 논리 연산자 > 대입 연산자
- 먼저 처리해야할 연산식은 **괄호( )** 사용 
<br>

> ### **연산자 연산 방향**
- 하나의 문장에 속한 동일한 종류의 연산자들은 실행 순서를 가진다.
- 대입 연산자, 증감 연산자: 오른쪽 -> 왼쪽
- 나머지 연산자: 왼쪽 -> 오른쪽
<br>

---
The **width** (p91) specifies the minimum number of characters in the output.

---
### 4-1. 조건문 : if , switch
- if 조건식 : true/false값을 산출하는 연산식 혹은 boolean타입 변수
- if, else if 문에서는 가장먼저 나온 true 실행문을 실행한 후 빠져나옴.

### 4-2. 반복문(looping) : for, while, do-while
**for, while** 
- for문은 반복 횟수를 알고 있을 때, while문은 조건에 따라 반복할 때 주로 사용

**do-while**
- do-while문은 블록 내부의 실행문을 우선 실행하고 그 결과에 따라서 반복 실행을 계속할지 결정 
- do-while문에서 while() 뒤에 반드시 세미콜론(;)

**break, continue**
- 주로 if문과 함께 사용
- 중첩된 반복문에서 break문은 가장 가까운 반복문만 종료하므로 바깥쪽 까지 종료하려면 바깥쪽 반복문에 이름(라벨)을 붙이고 `break 이름;`을 사용

`System.out.println()` : `System.out.print("\n")`과 같은 효과

---
### 5-1. 참조 타입과 참조 변수
**참조타입**
기본타입은 실제 값을 변수에 저장하지만, 참조타입은 번지를 통해 객체를 참조
- 바이트 코드 파일: 자바 소스 파일을 javac명령어로 컴파일한 파일
- JVM : 자바 가상 기계(Jave Virtual Machine)는 바이트 코드 파일을 운영체제를 위한 완전한 기계어로 번역하고 실행하는 역할을 함

★
== : 같은객체참조하는지 비교 (x)
equals() : 문자비교 (o)

### 5-2. 배열

**배열 복사**
System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) : 원본배열, 인덱스, 대상배열, 인덱스, 몇개

**향상된 for문**
for(타입 변수 : 배열){};

### 5-3. 열거 타입
**열거 타입**
열거 상수(한정된 값)을 저장하는 타임
**열거 타입 선언, 저장**
```java
public enum Week { MONDAY, TUESDAY... SUNDAY }

Week today = Week.SUNDAY;
```